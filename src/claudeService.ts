import Anthropic from "@anthropic-ai/sdk";
import { WindowState, WindowAction, AIRequest, AIResponse } from "./types";

export class ClaudeService {
  private anthropic: Anthropic;

  constructor(apiKey: string) {
    this.anthropic = new Anthropic({
      apiKey: apiKey,
    });
  }

  async generateApplicationDescriptions(
    appNames: string[]
  ): Promise<Array<{ name: string; observations: string[] }>> {
    try {
      const prompt = `‰ª•‰∏ã„ÅÆmacOS„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÁâπÂæ¥„ÇÑÁî®ÈÄî„Çí2-3ÂÄã„ÅÆË¶≥ÂØü‰∫ãÈ†Ö„Å®„Åó„Å¶Êó•Êú¨Ë™û„ÅßË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
      
      „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„É™„Çπ„Éà:
      ${appNames.join(", ")}
      
      ‰ª•‰∏ã„ÅÆJSONÂΩ¢Âºè„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ:
      [
        {
          "name": "„Ç¢„Éó„É™Âêç",
          "observations": [
            "Ë¶≥ÂØü‰∫ãÈ†Ö1",
            "Ë¶≥ÂØü‰∫ãÈ†Ö2",
            "Ë¶≥ÂØü‰∫ãÈ†Ö3"
          ]
        }
      ]
      
      ‰æã:
      [
        {
          "name": "Safari",
          "observations": [
            "Apple„ÅåÈñãÁô∫„Åó„ÅüWeb„Éñ„É©„Ç¶„Ç∂",
            "macOS„Å´Ê®ôÊ∫ñÊê≠Ëºâ„Åï„Çå„Å¶„ÅÑ„Çã",
            "„Éó„É©„Ç§„Éê„Ç∑„Éº‰øùË≠∑Ê©üËÉΩ„ÅåÂÖÖÂÆü„Åó„Å¶„ÅÑ„Çã"
          ]
        }
      ]`;

      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 20000,
        temperature: 0.3,
        messages: [
          {
            role: "user",
            content: prompt,
          },
        ],
      });

      const content = response.content[0];
      if (content.type === "text") {
        try {
          // Extract JSON from response
          const jsonMatch = content.text.match(/\[\s*\{[\s\S]*\}\s*\]/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            return parsed;
          }
        } catch (parseError) {
          console.error("Error parsing JSON response:", parseError);
        }
      }

      // Fallback: return apps with default observations
      return appNames.map((name) => ({
        name,
        observations: [this.getDefaultObservation(name)],
      }));
    } catch (error) {
      console.error("Error generating app descriptions:", error);
      return appNames.map((name) => ({
        name,
        observations: [this.getDefaultObservation(name)],
      }));
    }
  }

  private getDefaultObservation(appName: string): string {
    const defaults: Record<string, string> = {
      Safari: "Apple„ÅåÈñãÁô∫„Åó„ÅüWeb„Éñ„É©„Ç¶„Ç∂",
      Chrome: "Google„ÅåÈñãÁô∫„Åó„ÅüWeb„Éñ„É©„Ç¶„Ç∂",
      VSCode: "Microsoft„ÅåÈñãÁô∫„Åó„Åü„Ç≥„Éº„Éâ„Ç®„Éá„Ç£„Çø",
      Finder: "macOS„ÅÆ„Éï„Ç°„Ç§„É´ÁÆ°ÁêÜ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥",
      Terminal: "„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥Êìç‰ΩúÁî®„ÅÆ„Çø„Éº„Éü„Éä„É´„Ç¢„Éó„É™",
      Slack: "„ÉÅ„Éº„É†„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥Áî®„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„É≥„Ç∞„Ç¢„Éó„É™",
    };
    return defaults[appName] || `${appName}„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥`;
  }

  async analyzeWindowState(
    currentState: WindowState,
    userIntent: string,
    processes?: any[]
  ): Promise<AIResponse> {
    const systemPrompt = `You are a window management AI assistant. Your role is to analyze the current window layout and suggest optimal arrangements based on user intent.

You will receive:
1. Current window state with window IDs, app names, titles, and positions
2. Display information
3. System resource usage (CPU and memory)
4. User's desired outcome

CRITICAL RULES FOR WINDOW IDs:
- Each window has a unique ID in the format "appName-windowTitle"
- You MUST use the exact window ID provided in the window list
- For targetWindow: use a single window ID string
- For targetWindows: use an array of window ID strings
- NEVER use just the window title - always use the full ID

You should respond with structured JSON containing window actions to execute.

Available action types:
- move: Move a window to specific coordinates (requires targetWindow)
- resize: Change window dimensions (requires targetWindow)
- minimize: Minimize a window (requires targetWindow)
- maximize: Maximize a window to full screen (requires targetWindow)
- focus: Bring a window to front (requires targetWindow)
- arrange: Apply a layout pattern to multiple windows (requires targetWindows array)
  - Patterns: tile-left, tile-right, tile-grid, cascade, center
- close: Close a window (requires targetWindow)

Consider:
- User's workflow and app relationships
- Screen real estate optimization
- Maintaining visibility of important windows
- Ergonomic positioning (frequently used apps more accessible)
- System resource usage (close heavy resource apps if not needed)
- Apps that may be distracting or unnecessary for current task

When suggesting apps to close:
- Only suggest closing apps that are NOT essential for development (VSCode, Cursor, etc.)
- Consider resource usage (high CPU/memory usage)
- Consider apps that may distract from the current task
- Always provide clear reasons for closing each app
- Prioritize based on urgency (urgent, high, medium, low)
- Never suggest closing the 'Window AI Manager' itself

OUTPUT BREVITY RULES (critical):
- Keep each action.reasoning within 60 Japanese characters (Áü≠„ÅèË¶ÅÁÇπ„ÅÆ„Åø)„ÄÇ
- Keep overall explanation to a single sentence within 120 Japanese characters.
- Do not restate input data or list windows again.
- Prefer minimal action count that still satisfies the intent (‰∏äÈôê12‰ª∂)„ÄÇ`;

    // „Ç¢„Ç§„Ç≥„É≥„Éá„Éº„Çø„ÇíÈô§Â§ñ„Åó„Å§„Å§Áü≠„Ç≠„Éº„ÅßÂúßÁ∏ÆÔºà„Éà„Éº„ÇØ„É≥ÂâäÊ∏õÔºâ
    const compactState = {
      // w: windows
      w: currentState.windows.map((win) => ({
        id: win.id,
        a: win.appName, // app
        t: win.title ? win.title.substring(0, 30) : "Untitled", // title(max30)
        b: [win.bounds.x, win.bounds.y, win.bounds.width, win.bounds.height], // bounds
        m: win.isMinimized ? 1 : 0,
        f: win.isFocused ? 1 : 0,
        v: win.isVisible ? 1 : 0,
      })),
      // d: displays (ÊúÄÂ∞èÈôê)
      d: currentState.displays.map((dsp) => ({
        p: dsp.isPrimary ? 1 : 0,
        b: [dsp.bounds.x, dsp.bounds.y, dsp.bounds.width, dsp.bounds.height],
      })),
      a: currentState.activeApp, // active app
    } as any;

    // ÂÖ•Âäõ„ÅØÁü≠„Ç≠„ÉºJSON„ÅÆ„ÅøÔºàÊîπË°å„ÇÑË£ÖÈ£æ„Å™„ÅóÔºâ
    const compactProcesses = (processes || []).slice(0, 6).map((p) => ({
      n: p.name,
      c: Number(p.cpuUsage?.toFixed(1) || 0),
      m: Number(p.memoryUsage?.toFixed(0) || 0),
    }));

    const userMessage = JSON.stringify(
      {
        intent: userIntent,
        state: compactState,
        proc: compactProcesses,
        rules: {
          useExactWindowId: true,
          windowIdFormat: "appName-windowTitle",
        },
      },
      null,
      0
    );

    try {
      // „Éá„Éê„ÉÉ„Ç∞: ÈÄÅ‰ø°„Åô„Çã„Éó„É≠„É≥„Éó„ÉàÂÜÖÂÆπ
      console.log("üìù ===== Window Analysis Prompt =====");
      console.log("System Prompt:", systemPrompt);
      console.log("User Message:", userMessage);
      console.log("üìù =================================");

      const startTime = Date.now();
      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 900,
        temperature: 0.2,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: userMessage,
          },
        ],
        tools: [
          {
            name: "window_actions",
            description: "Provide window management actions",
            input_schema: {
              type: "object",
              properties: {
                actions: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      type: {
                        type: "string",
                        enum: [
                          "move",
                          "resize",
                          "minimize",
                          "maximize",
                          "focus",
                          "arrange",
                          "close",
                        ],
                      },
                      targetWindow: {
                        type: "string",
                        description: "Window ID for single window actions",
                      },
                      targetWindows: {
                        type: "array",
                        items: { type: "string" },
                        description: "Window IDs for multi-window actions",
                      },
                      parameters: {
                        type: "object",
                        properties: {
                          position: {
                            type: "object",
                            properties: {
                              x: { type: "number" },
                              y: { type: "number" },
                            },
                          },
                          size: {
                            type: "object",
                            properties: {
                              width: { type: "number" },
                              height: { type: "number" },
                            },
                          },
                          arrangement: {
                            type: "string",
                            enum: [
                              "tile-left",
                              "tile-right",
                              "tile-grid",
                              "cascade",
                              "center",
                            ],
                          },
                          display: { type: "string" },
                        },
                      },
                      reasoning: { type: "string" },
                    },
                    required: ["type", "reasoning"],
                  },
                },
                explanation: {
                  type: "string",
                  description:
                    "Overall explanation of the window management strategy",
                },
                confidence: {
                  type: "number",
                  minimum: 0,
                  maximum: 1,
                  description: "Confidence level in the suggested actions",
                },
                appsToClose: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      appName: { type: "string" },
                      reasons: { type: "array", items: { type: "string" } },
                      priority: {
                        type: "string",
                        enum: ["urgent", "high", "medium", "low"],
                      },
                      expectedBenefit: { type: "string" },
                    },
                    required: [
                      "appName",
                      "reasons",
                      "priority",
                      "expectedBenefit",
                    ],
                  },
                  description:
                    "Apps that should be closed to optimize performance or focus",
                },
              },
              required: ["actions", "explanation", "confidence"],
            },
          },
        ],
        tool_choice: { type: "tool", name: "window_actions" },
      });

      // „Éá„Éê„ÉÉ„Ç∞: „Éà„Éº„ÇØ„É≥‰ΩøÁî®Èáè„Å®ÂøúÁ≠îÊôÇÈñì
      const endTime = Date.now();
      const usage: any = (response as any).usage;
      if (usage) {
        console.log("üî¢ Token Usage:");
        console.log(`  - Input tokens: ${usage.input_tokens}`);
        console.log(`  - Output tokens: ${usage.output_tokens}`);
        console.log(
          `  - Total tokens: ${
            (usage.input_tokens ?? 0) + (usage.output_tokens ?? 0)
          }`
        );
      }
      console.log(`‚è±Ô∏è API Response Time: ${endTime - startTime}ms`);

      // Extract the tool use response
      const toolUse = response.content.find(
        (content: any): content is Anthropic.Messages.ToolUseBlock =>
          content.type === "tool_use" && content.name === "window_actions"
      );

      if (toolUse && typeof toolUse.input === "object") {
        const input = toolUse.input as any;
        return {
          actions: input.actions || [],
          explanation: input.explanation || "No explanation provided",
          confidence: input.confidence || 0.5,
          appsToClose: input.appsToClose || [],
        };
      }

      // Fallback response
      return {
        actions: [],
        explanation: "Unable to generate window actions",
        confidence: 0,
        appsToClose: [],
      };
    } catch (error) {
      console.error("Claude API error:", error);
      throw error;
    }
  }

  async suggestLayout(currentState: WindowState): Promise<AIResponse> {
    const suggestions = this.analyzeLayout(currentState);

    return {
      actions: suggestions,
      explanation: "Optimized layout based on current window configuration",
      confidence: 0.8,
    };
  }

  private analyzeLayout(state: WindowState): WindowAction[] {
    const actions: WindowAction[] = [];
    const primaryDisplay =
      state.displays.find((d) => d.isPrimary) || state.displays[0];

    if (!primaryDisplay) return actions;

    // Simple heuristic-based layout suggestions
    const visibleWindows = state.windows.filter(
      (w) => w.isVisible && !w.isMinimized
    );

    if (visibleWindows.length === 2) {
      // Side-by-side for two windows
      actions.push({
        type: "arrange",
        targetWindows: visibleWindows.map((w) => w.id),
        parameters: {
          arrangement: "tile-left",
        },
        reasoning: "Two windows work well in split-screen configuration",
      });
    } else if (visibleWindows.length <= 4) {
      // Grid for 3-4 windows
      actions.push({
        type: "arrange",
        targetWindows: visibleWindows.map((w) => w.id),
        parameters: {
          arrangement: "tile-grid",
        },
        reasoning: "Grid layout provides equal visibility for multiple windows",
      });
    } else {
      // Cascade for many windows
      actions.push({
        type: "arrange",
        targetWindows: visibleWindows.map((w) => w.id),
        parameters: {
          arrangement: "cascade",
        },
        reasoning: "Cascade arrangement helps manage many windows",
      });
    }

    return actions;
  }

  async analyzeUserProfile(
    appNames: string[],
    appDescriptions: Array<{ name: string; observations: string[] }>
  ): Promise<{
    userType: string;
    characteristics: string[];
    recommendations: string[];
    confidence: number;
  }> {
    const systemPrompt = `
„ÅÇ„Å™„Åü„ÅØ„É¶„Éº„Ç∂„Éº„ÅÆË°åÂãïÂàÜÊûê„Ç®„Ç≠„Çπ„Éë„Éº„Éà„Åß„Åô„ÄÇ
„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Çã„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å®„Åù„ÅÆÁâπÂæ¥„Åã„Çâ„ÄÅ„É¶„Éº„Ç∂„Éº„ÅÆÁâπÊÄß„ÇíÊ¥ûÂØü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

‰ª•‰∏ã„ÅÆË¶≥ÁÇπ„ÅßÂàÜÊûê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
1. „É¶„Éº„Ç∂„Éº„Çø„Ç§„ÉóÔºàËÅ∑Ê•≠„ÉªÂΩπÂâ≤Ôºâ
2. ÁâπÂæ¥„ÉªÊÄßÊ†ºÔºàÂâµÈÄ†ÁöÑ„ÄÅÂàÜÊûêÁöÑ„ÄÅ„Ç≥„É©„Éú„É¨„Éº„Ç∑„Éß„É≥ÈáçË¶ñ„Å™„Å©Ôºâ
3. ÊîπÂñÑÊèêÊ°àÔºàÂäπÁéáÂåñ„ÅÆ„Éí„É≥„ÉàÔºâ

„ÄåË®Ä„ÅÑÂΩì„Å¶„Å¶È©ö„Åã„Åõ„Çã„Äç„ÅÆ„Åß„ÅØ„Å™„Åè„ÄåÁêÜËß£„Åó„Å¶ÂΩπÁ´ã„Å§„Äç„Åì„Å®„ÇíÈáçË¶ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
`;

    const userMessage = `
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥‰∏ÄË¶ß: ${appNames.join(", ")}

„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë©≥Á¥∞:
${JSON.stringify(appDescriptions, null, 2)}
`;

    try {
      const response = await this.anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 1500,
        temperature: 0.4,
        system: systemPrompt,
        messages: [{ role: "user", content: userMessage }],
        tools: [
          {
            name: "analyze_user_profile",
            description: "Analyze user profile from installed applications",
            input_schema: {
              type: "object",
              properties: {
                userType: {
                  type: "string",
                  description:
                    "Primary user type or role (e.g., 'ÈñãÁô∫ËÄÖ', '„Éá„Ç∂„Ç§„Éä„Éº', '„Éì„Ç∏„Éç„Çπ„Éë„Éº„ÇΩ„É≥')",
                },
                characteristics: {
                  type: "array",
                  items: { type: "string" },
                  description: "Key characteristics and traits",
                },
                recommendations: {
                  type: "array",
                  items: { type: "string" },
                  description: "Actionable recommendations for improvement",
                },
                confidence: {
                  type: "number",
                  minimum: 0,
                  maximum: 1,
                  description: "Confidence in the analysis",
                },
              },
              required: [
                "userType",
                "characteristics",
                "recommendations",
                "confidence",
              ],
            },
          },
        ],
        tool_choice: { type: "tool", name: "analyze_user_profile" },
      });

      const toolUse = response.content.find(
        (content): content is any =>
          content.type === "tool_use" && content.name === "analyze_user_profile"
      );

      if (!toolUse) {
        return {
          userType: "‰∏ÄËà¨„É¶„Éº„Ç∂„Éº",
          characteristics: ["Êßò„ÄÖ„Å™„Ç¢„Éó„É™„ÇíÊ¥ªÁî®"],
          recommendations: ["„Çà„ÇäÂäπÁéáÁöÑ„Å™‰ΩúÊ•≠Áí∞Â¢É„ÅÆÊßãÁØâ„ÇíÊ§úË®é„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ"],
          confidence: 0.3,
        };
      }

      return toolUse.input;
    } catch (error) {
      console.error("Error analyzing user profile:", error);
      throw error;
    }
  }

  async generateWorkflowSuggestions(
    userProfile: any,
    appNames: string[],
    appDescriptions: Array<{ name: string; observations: string[] }>
  ): Promise<{
    workflows: Array<{
      name: string;
      description: string;
      apps: Array<{
        appName: string;
        role: string;
        reasoning: string;
      }>;
      tips: string[];
      confidence: number;
    }>;
  }> {
    const systemPrompt = `
„ÅÇ„Å™„Åü„ÅØ„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÊúÄÈÅ©Âåñ„ÅÆ„Ç®„Ç≠„Çπ„Éë„Éº„Éà„Åß„Åô„ÄÇ

„É¶„Éº„Ç∂„Éº„ÅÆ„Éó„É≠„Éï„Ç£„Éº„É´„Å®„Ç§„É≥„Çπ„Éà„Éº„É´Ê∏à„Åø„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åã„Çâ„ÄÅÂÖ∑‰ΩìÁöÑ„Å™‰ΩúÊ•≠„Éï„É≠„Éº„Çí3„Å§ÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÂêÑ‰ΩúÊ•≠„Éï„É≠„Éº„Å´„ÅØ‰ª•‰∏ã„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑÔºö
- ‰ΩúÊ•≠ÂêçÔºàÂÖ∑‰ΩìÁöÑ„ÅßË¶™„Åó„Åø„ÇÑ„Åô„ÅÑÂêçÂâçÔºâ
- ‰ΩúÊ•≠„ÅÆË™¨Êòé
- ‰ΩøÁî®„Åô„Çã„Ç¢„Éó„É™„Å®„Åù„ÅÆÂΩπÂâ≤
- ÂÆüË∑µÁöÑ„Å™„Ç≥„ÉÑ„ÇÑ„Éí„É≥„Éà

„Ç¢„Éó„É™„ÅÆÊèêÊ°àÂü∫Ê∫ñÔºö
1. ÂÆüÈöõ„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Çã„Ç¢„Éó„É™„ÅÆ„Åø‰ΩøÁî®
2. „Ç¢„Éó„É™„ÅÆÁâπÂæ¥ÔºàobservationsÔºâ„ÇíËÄÉÊÖÆ
3. „É¶„Éº„Ç∂„Éº„ÅÆÁâπÊÄß„Å´Âêà„Å£„ÅüÁµÑ„ÅøÂêà„Çè„Åõ
4. ÂÆüË∑µÁöÑ„ÅßÊó•Â∏∏ÁöÑ„Å´‰Ωø„Åà„Çã‰ΩúÊ•≠„Éï„É≠„Éº

Âá∫Âäõ„ÅØÊó•Êú¨Ë™û„Åß„ÄÅÂÆüÁî®ÊÄß„ÇíÈáçË¶ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
`;

    const userMessage = `
„É¶„Éº„Ç∂„Éº„Éó„É≠„Éï„Ç£„Éº„É´:
${JSON.stringify(userProfile, null, 2)}

Âà©Áî®ÂèØËÉΩ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥: ${appNames.join(", ")}

„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë©≥Á¥∞:
${JSON.stringify(appDescriptions, null, 2)}

„Åì„ÅÆ„É¶„Éº„Ç∂„Éº„ÅåÂäπÁéáÁöÑ„Å´‰ΩúÊ•≠„Åß„Åç„Çã„ÄÅÂÖ∑‰ΩìÁöÑ„Å™„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Çí3„Å§ÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
`;

    try {
      const response = await this.anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 2000,
        temperature: 0.4,
        system: systemPrompt,
        messages: [{ role: "user", content: userMessage }],
        tools: [
          {
            name: "generate_workflows",
            description:
              "Generate workflow suggestions based on user profile and apps",
            input_schema: {
              type: "object",
              properties: {
                workflows: {
                  type: "array",
                  maxItems: 3,
                  items: {
                    type: "object",
                    properties: {
                      name: { type: "string" },
                      description: { type: "string" },
                      apps: {
                        type: "array",
                        items: {
                          type: "object",
                          properties: {
                            appName: { type: "string" },
                            role: { type: "string" },
                            reasoning: { type: "string" },
                          },
                          required: ["appName", "role", "reasoning"],
                        },
                      },
                      tips: {
                        type: "array",
                        items: { type: "string" },
                      },
                      confidence: {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                      },
                    },
                    required: [
                      "name",
                      "description",
                      "apps",
                      "tips",
                      "confidence",
                    ],
                  },
                },
              },
              required: ["workflows"],
            },
          },
        ],
        tool_choice: { type: "tool", name: "generate_workflows" },
      });

      const toolUse = response.content.find(
        (content): content is any =>
          content.type === "tool_use" && content.name === "generate_workflows"
      );

      if (!toolUse) {
        return { workflows: [] };
      }

      return toolUse.input;
    } catch (error) {
      console.error("Error generating workflow suggestions:", error);
      throw error;
    }
  }

  async generateOptimalLayouts(
    userProfile: any,
    appNames: string[]
  ): Promise<{
    layouts: Array<{
      name: string;
      description: string;
      reasoning: string;
      preset: {
        name: string;
        description: string;
        windows: Array<{
          appName: string;
          position: { x: number; y: number };
          size: { width: number; height: number };
        }>;
      };
    }>;
    confidence: number;
  }> {
    const systemPrompt = `
„ÅÇ„Å™„Åü„ÅØ„Ç¶„Ç£„É≥„Éâ„Ç¶„É¨„Ç§„Ç¢„Ç¶„ÉàÊúÄÈÅ©Âåñ„ÅÆ„Ç®„Ç≠„Çπ„Éë„Éº„Éà„Åß„Åô„ÄÇ

„É¶„Éº„Ç∂„Éº„ÅÆ„Éó„É≠„Éï„Ç£„Éº„É´„Å®„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥‰∏ÄË¶ß„Åã„Çâ„ÄÅÊúÄÈÅ©„Å™„Ç¶„Ç£„É≥„Éâ„Ç¶ÈÖçÁΩÆ„Éë„Çø„Éº„É≥„Çí3„Å§ÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

macOS„ÅÆÊ®ôÊ∫ñÁöÑ„Å™„Éá„Ç£„Çπ„Éó„É¨„Ç§„Çµ„Ç§„Ç∫Ôºà1440x900Ôºâ„ÇíÂü∫Ê∫ñ„Å´„ÄÅÂÆüÁî®ÁöÑ„Å™ÈÖçÁΩÆ„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÂêÑ„É¨„Ç§„Ç¢„Ç¶„Éà„Å´„ÅØ‰ª•‰∏ã„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑÔºö
- ÂêçÂâçÔºàË¶™„Åó„Åø„ÇÑ„Åô„ÅÑÂêçÂâçÔºâ
- Ë™¨ÊòéÔºà„Å©„Çì„Å™‰ΩúÊ•≠„Å´ÈÅ©„Åó„Å¶„ÅÑ„Çã„ÅãÔºâ
- ÁêÜÁî±Ôºà„Å™„Åú„Åì„ÅÆ„É¶„Éº„Ç∂„Éº„Å´ÈÅ©„Åó„Å¶„ÅÑ„Çã„ÅãÔºâ
- ÂÖ∑‰ΩìÁöÑ„Å™Â∫ßÊ®ô„Å®„Çµ„Ç§„Ç∫

„Ç¶„Ç£„É≥„Éâ„Ç¶„ÅÆ„Çµ„Ç§„Ç∫„Å®‰ΩçÁΩÆ„ÅÆÂà∂Á¥ÑÔºö
- x, y: 0‰ª•‰∏ä
- width: ÊúÄÂ∞è400„ÄÅÊúÄÂ§ß1440
- height: ÊúÄÂ∞è300„ÄÅÊúÄÂ§ß900
- „Ç¶„Ç£„É≥„Éâ„Ç¶ÂêåÂ£´„ÅÆÈáçË§á„ÅØÊúÄÂ∞èÈôê„Å´
`;

    const userMessage = `
„É¶„Éº„Ç∂„Éº„Éó„É≠„Éï„Ç£„Éº„É´:
${JSON.stringify(userProfile, null, 2)}

Âà©Áî®ÂèØËÉΩ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥: ${appNames.join(", ")}

„É°„Ç§„É≥„Ç¢„Éó„É™ÔºàÈ†ªÁπÅ„Å´‰ΩøÁî®„Åï„Çå„Åù„ÅÜ„Å™„ÇÇ„ÅÆÔºâ„Çí‰∏≠ÂøÉ„Å´„ÄÅ3„Å§„ÅÆ„É¨„Ç§„Ç¢„Ç¶„Éà„Éë„Çø„Éº„É≥„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
`;

    try {
      const response = await this.anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 2000,
        temperature: 0.3,
        system: systemPrompt,
        messages: [{ role: "user", content: userMessage }],
        tools: [
          {
            name: "generate_layouts",
            description: "Generate optimal window layouts",
            input_schema: {
              type: "object",
              properties: {
                layouts: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      name: { type: "string" },
                      description: { type: "string" },
                      reasoning: { type: "string" },
                      preset: {
                        type: "object",
                        properties: {
                          name: { type: "string" },
                          description: { type: "string" },
                          windows: {
                            type: "array",
                            items: {
                              type: "object",
                              properties: {
                                appName: { type: "string" },
                                position: {
                                  type: "object",
                                  properties: {
                                    x: { type: "number" },
                                    y: { type: "number" },
                                  },
                                },
                                size: {
                                  type: "object",
                                  properties: {
                                    width: { type: "number" },
                                    height: { type: "number" },
                                  },
                                },
                              },
                              required: ["appName", "position", "size"],
                            },
                          },
                        },
                        required: ["name", "description", "windows"],
                      },
                    },
                    required: ["name", "description", "reasoning", "preset"],
                  },
                },
                confidence: {
                  type: "number",
                  minimum: 0,
                  maximum: 1,
                },
              },
              required: ["layouts", "confidence"],
            },
          },
        ],
        tool_choice: { type: "tool", name: "generate_layouts" },
      });

      const toolUse = response.content.find(
        (content): content is any =>
          content.type === "tool_use" && content.name === "generate_layouts"
      );

      if (!toolUse) {
        return {
          layouts: [],
          confidence: 0,
        };
      }

      return toolUse.input;
    } catch (error) {
      console.error("Error generating layouts:", error);
      throw error;
    }
  }

  async suggestAppsForTask(
    userPrompt: string,
    applicationGraph: any[]
  ): Promise<{
    highConfidence: string[];
    lowConfidence: string[];
    reasoning: string;
  }> {
    const systemPrompt = `
„ÅÇ„Å™„Åü„ÅØ„É¶„Éº„Ç∂„Éº„ÅÆ„Çø„Çπ„ÇØ„Åã„ÇâÂøÖË¶Å„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊé®Ëñ¶„Åô„Çã„Ç®„Ç≠„Çπ„Éë„Éº„Éà„Åß„Åô„ÄÇ

„É¶„Éº„Ç∂„Éº„ÅÆ„Éó„É≠„É≥„Éó„Éà„Å®„ÄÅÂà©Áî®ÂèØËÉΩ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„É™„Çπ„Éà„ÇíÂàÜÊûê„Åó„Å¶„ÄÅ
„Çø„Çπ„ÇØ„Å´ÊúÄÈÅ©„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅØ‰ª•‰∏ã„ÅÆ2„Å§„ÅÆ„Ç´„ÉÜ„Ç¥„É™„Éº„Å´ÂàÜÈ°û„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
- highConfidence: „Çø„Çπ„ÇØ„Å´Á¢∫ÂÆü„Å´ÂøÖË¶Å„Å®ÊÄù„Çè„Çå„Çã„Ç¢„Éó„É™Ôºà„Éá„Éï„Ç©„É´„Éà„Åß„ÉÅ„Çß„ÉÉ„ÇØÊ∏à„ÅøÔºâ
- lowConfidence: „ÅÇ„Å£„ÅüÊñπ„ÅåËâØ„ÅÑ„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„Ç¢„Éó„É™Ôºà„Éá„Éï„Ç©„É´„Éà„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Å™„ÅóÔºâ

Âà§Êñ≠Âü∫Ê∫ñÔºö
1. „Çø„Çπ„ÇØ„Å®„ÅÆÁõ¥Êé•ÁöÑ„Å™Èñ¢ÈÄ£ÊÄß
2. „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ‰∏ªË¶Å„Å™Áî®ÈÄî
3. ‰∏ÄËà¨ÁöÑ„Å™„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Åß„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ
4. „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆË™¨ÊòéÔºàobservationsÔºâ„Å®„ÅÆÂêàËá¥Â∫¶

ËøîÁ≠î„ÅØÊßãÈÄ†Âåñ„Åï„Çå„ÅüJSON„ÅÆ„Åø„Åß„ÄÅË™¨Êòé„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ
`;

    const userMessage = `
„Çø„Çπ„ÇØ: ${userPrompt}

Âà©Áî®ÂèØËÉΩ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥:
${JSON.stringify(applicationGraph, null, 2)}
`;

    try {
      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 20000,
        temperature: 0.3,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: userMessage,
          },
        ],
        tools: [
          {
            name: "suggest_apps",
            description: "Suggest applications for the user's task",
            input_schema: {
              type: "object",
              properties: {
                highConfidence: {
                  type: "array",
                  items: { type: "string" },
                  description: "Apps that are definitely needed for the task",
                },
                lowConfidence: {
                  type: "array",
                  items: { type: "string" },
                  description: "Apps that might be helpful for the task",
                },
                reasoning: {
                  type: "string",
                  description: "Brief explanation of the suggestions",
                },
              },
              required: ["highConfidence", "lowConfidence", "reasoning"],
            },
          },
        ],
        tool_choice: { type: "tool", name: "suggest_apps" },
      });

      const toolUse = response.content.find(
        (content): content is any =>
          content.type === "tool_use" && content.name === "suggest_apps"
      );

      if (!toolUse) {
        console.warn("No tool use in response, using fallback");
        return {
          highConfidence: [],
          lowConfidence: [],
          reasoning: "Could not determine relevant applications",
        };
      }

      return toolUse.input as {
        highConfidence: string[];
        lowConfidence: string[];
        reasoning: string;
      };
    } catch (error) {
      console.error("Error suggesting apps:", error);
      throw error;
    }
  }
}
