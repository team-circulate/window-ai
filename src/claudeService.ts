import Anthropic from "@anthropic-ai/sdk";
import { WindowState, WindowAction, AIRequest, AIResponse } from "./types";

export class ClaudeService {
  private anthropic: Anthropic;

  constructor(apiKey: string) {
    this.anthropic = new Anthropic({
      apiKey: apiKey,
    });
  }

  async generateApplicationDescriptions(
    appNames: string[]
  ): Promise<Array<{ name: string; observations: string[] }>> {
    try {
      const prompt = `‰ª•‰∏ã„ÅÆmacOS„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÁâπÂæ¥„ÇÑÁî®ÈÄî„Çí2-3ÂÄã„ÅÆË¶≥ÂØü‰∫ãÈ†Ö„Å®„Åó„Å¶Êó•Êú¨Ë™û„ÅßË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
      
      „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„É™„Çπ„Éà:
      ${appNames.join(", ")}
      
      ‰ª•‰∏ã„ÅÆJSONÂΩ¢Âºè„ÅßËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ:
      [
        {
          "name": "„Ç¢„Éó„É™Âêç",
          "observations": [
            "Ë¶≥ÂØü‰∫ãÈ†Ö1",
            "Ë¶≥ÂØü‰∫ãÈ†Ö2",
            "Ë¶≥ÂØü‰∫ãÈ†Ö3"
          ]
        }
      ]
      
      ‰æã:
      [
        {
          "name": "Safari",
          "observations": [
            "Apple„ÅåÈñãÁô∫„Åó„ÅüWeb„Éñ„É©„Ç¶„Ç∂",
            "macOS„Å´Ê®ôÊ∫ñÊê≠Ëºâ„Åï„Çå„Å¶„ÅÑ„Çã",
            "„Éó„É©„Ç§„Éê„Ç∑„Éº‰øùË≠∑Ê©üËÉΩ„ÅåÂÖÖÂÆü„Åó„Å¶„ÅÑ„Çã"
          ]
        }
      ]`;

      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 20000,
        temperature: 0.3,
        messages: [
          {
            role: "user",
            content: prompt,
          },
        ],
      });

      const content = response.content[0];
      if (content.type === "text") {
        try {
          // Extract JSON from response
          const jsonMatch = content.text.match(/\[\s*\{[\s\S]*\}\s*\]/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            return parsed;
          }
        } catch (parseError) {
          console.error("Error parsing JSON response:", parseError);
        }
      }

      // Fallback: return apps with default observations
      return appNames.map((name) => ({
        name,
        observations: [this.getDefaultObservation(name)],
      }));
    } catch (error) {
      console.error("Error generating app descriptions:", error);
      return appNames.map((name) => ({
        name,
        observations: [this.getDefaultObservation(name)],
      }));
    }
  }

  private getDefaultObservation(appName: string): string {
    const defaults: Record<string, string> = {
      Safari: "Apple„ÅåÈñãÁô∫„Åó„ÅüWeb„Éñ„É©„Ç¶„Ç∂",
      Chrome: "Google„ÅåÈñãÁô∫„Åó„ÅüWeb„Éñ„É©„Ç¶„Ç∂",
      VSCode: "Microsoft„ÅåÈñãÁô∫„Åó„Åü„Ç≥„Éº„Éâ„Ç®„Éá„Ç£„Çø",
      Finder: "macOS„ÅÆ„Éï„Ç°„Ç§„É´ÁÆ°ÁêÜ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥",
      Terminal: "„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥Êìç‰ΩúÁî®„ÅÆ„Çø„Éº„Éü„Éä„É´„Ç¢„Éó„É™",
      Slack: "„ÉÅ„Éº„É†„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥Áî®„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„É≥„Ç∞„Ç¢„Éó„É™",
    };
    return defaults[appName] || `${appName}„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥`;
  }

  async analyzeWindowState(
    currentState: WindowState,
    userIntent: string,
    processes?: any[]
  ): Promise<AIResponse> {
    const systemPrompt = `You are a window management AI assistant. Your role is to analyze the current window layout and suggest optimal arrangements based on user intent.

You will receive:
1. Current window state with window IDs, app names, titles, and positions
2. Display information
3. System resource usage (CPU and memory)
4. User's desired outcome

CRITICAL RULES FOR WINDOW IDs:
- Each window has a unique ID in the format "appName-windowTitle"
- You MUST use the exact window ID provided in the window list
- For targetWindow: use a single window ID string
- For targetWindows: use an array of window ID strings
- NEVER use just the window title - always use the full ID

You should respond with structured JSON containing window actions to execute.

Available action types:
- move: Move a window to specific coordinates (requires targetWindow)
- resize: Change window dimensions (requires targetWindow)
- minimize: Minimize a window (requires targetWindow)
- maximize: Maximize a window to full screen (requires targetWindow)
- focus: Bring a window to front (requires targetWindow)
- arrange: Apply a layout pattern to multiple windows (requires targetWindows array)
  - Patterns: tile-left, tile-right, tile-grid, cascade, center
- close: Close a window (requires targetWindow)

Consider:
- User's workflow and app relationships
- Screen real estate optimization
- Maintaining visibility of important windows
- Ergonomic positioning (frequently used apps more accessible)
- System resource usage (close heavy resource apps if not needed)
- Apps that may be distracting or unnecessary for current task

When suggesting apps to close:
- Only suggest closing apps that are NOT essential for development (VSCode, Cursor, etc.)
- Consider resource usage (high CPU/memory usage)
- Consider apps that may distract from the current task
- Always provide clear reasons for closing each app
- Prioritize based on urgency (urgent, high, medium, low)
- Never suggest closing the 'Window AI Manager' itself

OUTPUT BREVITY RULES (critical):
- Keep each action.reasoning within 60 Japanese characters (Áü≠„ÅèË¶ÅÁÇπ„ÅÆ„Åø)„ÄÇ
- Keep overall explanation to a single sentence within 120 Japanese characters.
- Do not restate input data or list windows again.
- Prefer minimal action count that still satisfies the intent (‰∏äÈôê12‰ª∂)„ÄÇ`;

    // „Ç¢„Ç§„Ç≥„É≥„Éá„Éº„Çø„ÇíÈô§Â§ñ„Åó„Å§„Å§Áü≠„Ç≠„Éº„ÅßÂúßÁ∏ÆÔºà„Éà„Éº„ÇØ„É≥ÂâäÊ∏õÔºâ
    const compactState = {
      // w: windows
      w: currentState.windows.map((win) => ({
        id: win.id,
        a: win.appName, // app
        t: win.title ? win.title.substring(0, 30) : "Untitled", // title(max30)
        b: [win.bounds.x, win.bounds.y, win.bounds.width, win.bounds.height], // bounds
        m: win.isMinimized ? 1 : 0,
        f: win.isFocused ? 1 : 0,
        v: win.isVisible ? 1 : 0,
      })),
      // d: displays (ÊúÄÂ∞èÈôê)
      d: currentState.displays.map((dsp) => ({
        p: dsp.isPrimary ? 1 : 0,
        b: [dsp.bounds.x, dsp.bounds.y, dsp.bounds.width, dsp.bounds.height],
      })),
      a: currentState.activeApp, // active app
    } as any;

    // ÂÖ•Âäõ„ÅØÁü≠„Ç≠„ÉºJSON„ÅÆ„ÅøÔºàÊîπË°å„ÇÑË£ÖÈ£æ„Å™„ÅóÔºâ
    const compactProcesses = (processes || [])
      .slice(0, 6)
      .map((p) => ({
        n: p.name,
        c: Number(p.cpuUsage?.toFixed(1) || 0),
        m: Number(p.memoryUsage?.toFixed(0) || 0),
      }));

    const userMessage = JSON.stringify(
      {
        intent: userIntent,
        state: compactState,
        proc: compactProcesses,
        rules: {
          useExactWindowId: true,
          windowIdFormat: "appName-windowTitle",
        },
      },
      null,
      0
    );

    try {
      // „Éá„Éê„ÉÉ„Ç∞: ÈÄÅ‰ø°„Åô„Çã„Éó„É≠„É≥„Éó„ÉàÂÜÖÂÆπ
      console.log("üìù ===== Window Analysis Prompt =====");
      console.log("System Prompt:", systemPrompt);
      console.log("User Message:", userMessage);
      console.log("üìù =================================");

      const startTime = Date.now();
      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 900,
        temperature: 0.2,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: userMessage,
          },
        ],
        tools: [
          {
            name: "window_actions",
            description: "Provide window management actions",
            input_schema: {
              type: "object",
              properties: {
                actions: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      type: {
                        type: "string",
                        enum: [
                          "move",
                          "resize",
                          "minimize",
                          "maximize",
                          "focus",
                          "arrange",
                          "close",
                        ],
                      },
                      targetWindow: {
                        type: "string",
                        description: "Window ID for single window actions",
                      },
                      targetWindows: {
                        type: "array",
                        items: { type: "string" },
                        description: "Window IDs for multi-window actions",
                      },
                      parameters: {
                        type: "object",
                        properties: {
                          position: {
                            type: "object",
                            properties: {
                              x: { type: "number" },
                              y: { type: "number" },
                            },
                          },
                          size: {
                            type: "object",
                            properties: {
                              width: { type: "number" },
                              height: { type: "number" },
                            },
                          },
                          arrangement: {
                            type: "string",
                            enum: [
                              "tile-left",
                              "tile-right",
                              "tile-grid",
                              "cascade",
                              "center",
                            ],
                          },
                          display: { type: "string" },
                        },
                      },
                      reasoning: { type: "string" },
                    },
                    required: ["type", "reasoning"],
                  },
                },
                explanation: {
                  type: "string",
                  description:
                    "Overall explanation of the window management strategy",
                },
                confidence: {
                  type: "number",
                  minimum: 0,
                  maximum: 1,
                  description: "Confidence level in the suggested actions",
                },
                appsToClose: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      appName: { type: "string" },
                      reasons: { type: "array", items: { type: "string" } },
                      priority: {
                        type: "string",
                        enum: ["urgent", "high", "medium", "low"],
                      },
                      expectedBenefit: { type: "string" },
                    },
                    required: [
                      "appName",
                      "reasons",
                      "priority",
                      "expectedBenefit",
                    ],
                  },
                  description:
                    "Apps that should be closed to optimize performance or focus",
                },
              },
              required: ["actions", "explanation", "confidence"],
            },
          },
        ],
        tool_choice: { type: "tool", name: "window_actions" },
      });

      // „Éá„Éê„ÉÉ„Ç∞: „Éà„Éº„ÇØ„É≥‰ΩøÁî®Èáè„Å®ÂøúÁ≠îÊôÇÈñì
      const endTime = Date.now();
      const usage: any = (response as any).usage;
      if (usage) {
        console.log("üî¢ Token Usage:");
        console.log(`  - Input tokens: ${usage.input_tokens}`);
        console.log(`  - Output tokens: ${usage.output_tokens}`);
        console.log(
          `  - Total tokens: ${
            (usage.input_tokens ?? 0) + (usage.output_tokens ?? 0)
          }`
        );
      }
      console.log(`‚è±Ô∏è API Response Time: ${endTime - startTime}ms`);

      // Extract the tool use response
      const toolUse = response.content.find(
        (content: any): content is Anthropic.Messages.ToolUseBlock =>
          content.type === "tool_use" && content.name === "window_actions"
      );

      if (toolUse && typeof toolUse.input === "object") {
        const input = toolUse.input as any;
        return {
          actions: input.actions || [],
          explanation: input.explanation || "No explanation provided",
          confidence: input.confidence || 0.5,
          appsToClose: input.appsToClose || [],
        };
      }

      // Fallback response
      return {
        actions: [],
        explanation: "Unable to generate window actions",
        confidence: 0,
        appsToClose: [],
      };
    } catch (error) {
      console.error("Claude API error:", error);
      throw error;
    }
  }

  async suggestLayout(currentState: WindowState): Promise<AIResponse> {
    const suggestions = this.analyzeLayout(currentState);

    return {
      actions: suggestions,
      explanation: "Optimized layout based on current window configuration",
      confidence: 0.8,
    };
  }

  private analyzeLayout(state: WindowState): WindowAction[] {
    const actions: WindowAction[] = [];
    const primaryDisplay =
      state.displays.find((d) => d.isPrimary) || state.displays[0];

    if (!primaryDisplay) return actions;

    // Simple heuristic-based layout suggestions
    const visibleWindows = state.windows.filter(
      (w) => w.isVisible && !w.isMinimized
    );

    if (visibleWindows.length === 2) {
      // Side-by-side for two windows
      actions.push({
        type: "arrange",
        targetWindows: visibleWindows.map((w) => w.id),
        parameters: {
          arrangement: "tile-left",
        },
        reasoning: "Two windows work well in split-screen configuration",
      });
    } else if (visibleWindows.length <= 4) {
      // Grid for 3-4 windows
      actions.push({
        type: "arrange",
        targetWindows: visibleWindows.map((w) => w.id),
        parameters: {
          arrangement: "tile-grid",
        },
        reasoning: "Grid layout provides equal visibility for multiple windows",
      });
    } else {
      // Cascade for many windows
      actions.push({
        type: "arrange",
        targetWindows: visibleWindows.map((w) => w.id),
        parameters: {
          arrangement: "cascade",
        },
        reasoning: "Cascade arrangement helps manage many windows",
      });
    }

    return actions;
  }

  async suggestAppsForTask(
    userPrompt: string,
    applicationGraph: any[]
  ): Promise<{
    highConfidence: string[];
    lowConfidence: string[];
    reasoning: string;
  }> {
    const systemPrompt = `
„ÅÇ„Å™„Åü„ÅØ„É¶„Éº„Ç∂„Éº„ÅÆ„Çø„Çπ„ÇØ„Åã„ÇâÂøÖË¶Å„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊé®Ëñ¶„Åô„Çã„Ç®„Ç≠„Çπ„Éë„Éº„Éà„Åß„Åô„ÄÇ

„É¶„Éº„Ç∂„Éº„ÅÆ„Éó„É≠„É≥„Éó„Éà„Å®„ÄÅÂà©Áî®ÂèØËÉΩ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„É™„Çπ„Éà„ÇíÂàÜÊûê„Åó„Å¶„ÄÅ
„Çø„Çπ„ÇØ„Å´ÊúÄÈÅ©„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅØ‰ª•‰∏ã„ÅÆ2„Å§„ÅÆ„Ç´„ÉÜ„Ç¥„É™„Éº„Å´ÂàÜÈ°û„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
- highConfidence: „Çø„Çπ„ÇØ„Å´Á¢∫ÂÆü„Å´ÂøÖË¶Å„Å®ÊÄù„Çè„Çå„Çã„Ç¢„Éó„É™Ôºà„Éá„Éï„Ç©„É´„Éà„Åß„ÉÅ„Çß„ÉÉ„ÇØÊ∏à„ÅøÔºâ
- lowConfidence: „ÅÇ„Å£„ÅüÊñπ„ÅåËâØ„ÅÑ„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„Ç¢„Éó„É™Ôºà„Éá„Éï„Ç©„É´„Éà„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Å™„ÅóÔºâ

Âà§Êñ≠Âü∫Ê∫ñÔºö
1. „Çø„Çπ„ÇØ„Å®„ÅÆÁõ¥Êé•ÁöÑ„Å™Èñ¢ÈÄ£ÊÄß
2. „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ‰∏ªË¶Å„Å™Áî®ÈÄî
3. ‰∏ÄËà¨ÁöÑ„Å™„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Åß„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ
4. „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆË™¨ÊòéÔºàobservationsÔºâ„Å®„ÅÆÂêàËá¥Â∫¶

ËøîÁ≠î„ÅØÊßãÈÄ†Âåñ„Åï„Çå„ÅüJSON„ÅÆ„Åø„Åß„ÄÅË™¨Êòé„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ
`;

    const userMessage = `
„Çø„Çπ„ÇØ: ${userPrompt}

Âà©Áî®ÂèØËÉΩ„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥:
${JSON.stringify(applicationGraph, null, 2)}
`;

    try {
      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 20000,
        temperature: 0.3,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: userMessage,
          },
        ],
        tools: [
          {
            name: "suggest_apps",
            description: "Suggest applications for the user's task",
            input_schema: {
              type: "object",
              properties: {
                highConfidence: {
                  type: "array",
                  items: { type: "string" },
                  description: "Apps that are definitely needed for the task",
                },
                lowConfidence: {
                  type: "array",
                  items: { type: "string" },
                  description: "Apps that might be helpful for the task",
                },
                reasoning: {
                  type: "string",
                  description: "Brief explanation of the suggestions",
                },
              },
              required: ["highConfidence", "lowConfidence", "reasoning"],
            },
          },
        ],
        tool_choice: { type: "tool", name: "suggest_apps" },
      });

      const toolUse = response.content.find(
        (content): content is any =>
          content.type === "tool_use" && content.name === "suggest_apps"
      );

      if (!toolUse) {
        console.warn("No tool use in response, using fallback");
        return {
          highConfidence: [],
          lowConfidence: [],
          reasoning: "Could not determine relevant applications",
        };
      }

      return toolUse.input as {
        highConfidence: string[];
        lowConfidence: string[];
        reasoning: string;
      };
    } catch (error) {
      console.error("Error suggesting apps:", error);
      throw error;
    }
  }
}
